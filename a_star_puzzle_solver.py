'''
Assignment #3
Intro to AI: 8 Puzzle using A*
Daniel Quintana Menjivar
Inspired by: https://www.youtube.com/watch?v=GuCzYxHa7iA
'''
import time
import random
import collections
import itertools

class Node: #  reprents a Solver node

    def __init__(self, puzzle, parent=None, action=None):
        self.puzzle = puzzle #  a puzzle instance
        self.parent = parent #  the preceeding node generated by solver, if any
        self.action = action #  the action taken to produce the puzzle, if any
        
        if (self.parent != None):
           self.g = parent.g + 1
        else:
            self.g = 0
    
    @property # python simplification of getters and setters
    def score(self):
        return(self.g + self.h)

    @property
    def state(self): #  returns a hashavle representation of self
        return str(self)

    @property
    def path(self): #  reconstructs a apth from the root to the parent
        node = self
        p = []
        while node:
            p.append(node)
            node = node.parent
        yield from reversed(p)

    @property
    def solved(self): #  wrapper checks if puzzle is solved
        return self.puzzle.solved

    @property
    def actions(self): #  wrapper for actions accesible in the current state
        return self.puzzle.actions

    @property
    def h(self):
        return self.puzzle.manhattan

    @property
    def f(self):
        return self.h + self.g

    def __str__(self):
        return str(self.puzzle)

class Solver: #  an 8 puzzle solver

    def __init__(self, start):
        self.start = start #  a Puzzle instance

    def solve(self): #performs BFS and returns a path to solution if it exists
        queue = collections.deque([Node(self.start)])
        seen = set()
        seen.add(queue[0].state)
        while queue:
            queue = collections.deque(sorted(list(queue), key=lambda node: node.f))
            node = queue.popleft()
            
            if node.solved:
                return node.path
    
            for move, action in node.actions:
                child = Node(move(), node, action)
    
                if child.state not in seen:
                    queue.appendleft(child)
                    seen.add(child.state)

class Puzzle: #  represents an 8 puzzle 
    
    def __init__(self, board):
       self.width = len(board[0])
       self.board = board

    @property
    def solved(self): #  if numbers are in increasing order from left to right and '0' is in the last position
        N = self.width * self.width
        return str(self) == ''.join(map(str, range(1, N))) + '0'

    @property
    def actions(self):

        def create_move(at, to):
            return lambda: self._move(at, to)
        
        moves = []
        for i, j in itertools.product(range(self.width), range(self.width)):

            directions = {'R':(i, j-1),
                      'L':(i, j+1),
                      'D':(i-1, j),
                      'U':(i+1, j)}

            for action, (r, c) in directions.items():
                if r >= 0 and c >= 0 and r < self.width and c < self.width and self.board[r][c] == 0:
                    move = create_move((i, j), (r, c)), action
                    moves.append(move)
        
        return moves #  a list of move, action pair

    @property
    def manhattan(self):
        distance = 0
        b_param =0
        if len(board) == 3:
            b_param = 3
        elif len(board) == 4:
            b_param =4
        else:
            print("Not valid board!")

        for i in range(b_param):
            for j in range(b_param):
                if self.board[i][j] != 0:
                    x, y = divmod(self.board[i][j] - 1, b_param)
                    distance += abs(x - i) + abs(y - j)
        return distance
    
    def shuffle(self): #return a puzzle that has been shuffled with 1K moves
        puzzle = self

        for _ in range(1000):
            puzzle = random.choice(puzzle.actions)[0]()
        return Puzzle(board)

    def copy(self): #  returns a new puzzle with the same board as self
        board = []
        for row in self.board:
            board.append([x for x in row])
        return Puzzle(board)

    def _move(self, at, to): 
        copy = self.copy()
        i, j = at
        r, c = to
        copy.board[i][j], copy.board[r][c] = copy.board[r][c], copy.board[i][j]
        return copy #  returns a new puzzle where at and to have been swapped

    def printBoard(self):
        for row in self.board:
            print(row)
        print()

    def __str__(self):
        return ''.join(map(str, self))

    def __iter__(self):
        for row in self.board:
            yield from row

desicion = ' '
while desicion != 8 or desicion !=15:
    desicion = int(input("Should it be 8 puzzle or 15 puzzle? Enter 8 or 15."))
    if desicion == 8:
        print('8-Puzzle A* Solver')
        print('Enter the puzzle you want to solve like this \'1 2 3 4 5 6 7 8 0\' with \'0\' being the empty space')
        puzzle = [int(x) for x in input().split()]
        board = [puzzle[0:3], puzzle[3:6], puzzle[6:9]]
        #board = [[2,0,5],[8,3,4],[7,6,1]]
    elif desicion == 15:
        print('15-Puzzle A* Solver')
        print('Enter the puzzle you want to solve like this \'1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0\' with \'0\' being the empty space')
        puzzle = [int(x) for x in input().split()]
        board = [puzzle[0:4], puzzle[4:8], puzzle[8:12], puzzle[12:16]]
    else:
        print("Invalid input. Try again.")

puzzle = Puzzle(board)
s = Solver(puzzle)
tic = time.time()
p = s.solve()
toc = time.time()

steps = 0
for node in p:
    print(node.action)
    node.puzzle.printBoard()
    steps += 1

print("Total number of steps: " + str(steps))
print("Total amount of time in search: " + str(toc - tic) + " second(s)")




